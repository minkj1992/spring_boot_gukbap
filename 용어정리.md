# 키워드 정리

## 아키텍쳐
- `Service`
    - Business Logic이 들어있는 가장 중요한 Layer
    - **`Service`: `DAO` = 1 : 1**이어야 한다. 이유는
        1. Business Logic에는 `데이터 유효성 검사`, `무결성 검사`등을 포함시켜야 하는데, 이 과정없이 Repository에서 데이터를 조작한다면, **데이터 무결성을 보장할 수 없다.** (언제든지 원치 않는 이상한 데이터가 삽입/수정 될 수 있다)
        2. 중복 코드 유발방지 ( 서비스단 비지니스 코드가 DAO(레퍼지토리)
    - Service 계층에서 다른 Service를 참조가능하다. 그러나 계층 구조를 지녀야 한다. ( 순환참조 방지)

- `Repository`
    - [DAO와 REPOSITORY 논쟁]('./DAO와_REPOSITORY_논쟁.md')
    - `DAO Layer`라고 흔히 이야기 함.
        - (A) Hibernate,JpA가 제공하는 API는 Object -> RDB이므로 Object Relation Mapper
        - 반면 (B) Mybatis의 경우 SQL -> Bean (SQL Mapper)
        - (A)는 의존성이 Object 객체, (B)는 SQL에 존재한다.
        - (B)는 전체 DB에 대해 DAO(Data Access 하는 Facade(창구) 역할을 수행하여 빈역한 Getter/Setter정도 만 지니고 있지만, (A)는 Object관점으로 존재하기 때문에 `Bean`에 대한 검색/정렬과 같은 API를 포함한 리치도메인으로 작성할 수 있다.
    - 각종 다양한 Storage에 데이터 CRUD를 위한 모든 객체들의 Layer
- `Controller` (Representation)
    - Client가 이용할 End point
    - Client 요청에 어떤 응답을 처리할지 정의/결정하는 곳




## JPA
- `@Repository`
- `@PersistenceContext`
- `EntityManagerFactory`
- `EntityManager`
- `@DiscriminatorValue("B")`
    - 일반적으로 `SINGLE_TABLE` 전략에서 해당 테이블에 `type column`으로 저장된다.
    - 엔티티 저장시 구분column에 입력할 값을 지정한다.
- `@Column(name = "member_id")`
    - DB 칼럼명
    - 엔티티는 클래스로 타입을 유추할 수 있지만, DB 테이블은 타입이 없다.
- `@Embedded Address address`
    - `Address`라는 클래스에 여러 필드들을 추가해주고, 이를 set 시켜주는 생성자만을 지닌 클래스를 생성하면 이는 `@Embeddable`로 설정할 수있다.
    - 이를 통해서 도로명, 도시, zipcode등을 하나의 변수로 사용가능하다.
    - `@Embedded`를 사용한다면, `@Embeddable`은 생략가능하다.


- `@OneToMany(mappedBy = "member")`
    - mappdedBy는 연관관계 '을'이 사용
    - mappdedBy에 들어가는 인자는, 연관관계주인이 가지고 있는 필드명 (fk가 된다 DB상)
- `@JoinColumn(name = "member_id")`
    - FK 부여, 연관관계의 주인
- `@Table(name = "orders")`
    - 테이블 이름
- `@ManyToOne(fetch = FetchType.LAZY)`
    - 즉시로딩 vs 지연로딩
        - `Eager(즉시)`: Entity를 조회할 때 연관된 엔티티도 함께 조회한다.
        - `LAZY(지연)`: Entity를 조회할 때 연관된 엔티티를 실제 사용할 때 조회한다. 참조하지 않은 관계있는 Entity들은 지연로딩 엔티티를 초기화할때 생성해준뒤, 데이터가 필요한 순간이 되어서야 DB를 조회하여 `proxy object`를 초기화한다. 단 `컬렉션`은 컬렉션 래퍼가 지연로딩을 처리해준다. 
- `@OneToOne(cascade = CascadeType.ALL)`
    - 부모가 Create, Delete시 영속성컨텍스트에 넣거나 뺴준다.
    - 자식은 @Entity 타입을 써주어야 할까?

- `@Enumerated(EnumType.STRING)`
    - EnumType은 기본적으로 order를 취하지만, 이는 중간에 요소가 insert될 경우 잘못된 개체에 접근하게 되는 문제가 일어난다.

## Lombok
- `@NoArgsConstructor(access = AccessLevel.PROTECTED)`
    - 자바 엔티티나 임베디드 타입은 리플렉션 때문에 자바 default constructor를 public 또는 protected로 설정해야한다. protected를 사용하는 것이 좀더 안전하다.
    - @Entity를 생성할때는 해당 lombok을 사용하면 편리하다.
## Test
- `@RunWith(SpringRunner.class)`: `JUnit`가 테스트때 실행시킬 `class`를 명시해 준다.

- `@SpringBootTest`: 스프링부트 어플리케이션 테스트에 필요한 거의 모든 의존성을 받아온다.